<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[The hiding rule in C++]]></title>
    <url>%2F2019%2F09%2F13%2FThe-hiding-rule-in-C%2F</url>
    <content type="text"><![CDATA[是什么更里层的scope里的变量名会使外层的同名变量被隐藏，即使该名字是一个签名不一样的函数。 12345678910111213141516#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;namespace A &#123; char x;&#125;;namespace B &#123; using namespace A; int x;&#125;;int main() &#123; cout &lt;&lt; typeid(B::x).name() &lt;&lt; endl;&#125; 将会输出：1int 问题如果在继承类里定义一个函数f, 则基类里的所有名为f的函数都将被隐藏，即使返回类型和参数不一样。12345678910111213struct A &#123; void f() &#123; &#125;&#125;;struct B : A &#123; void f(int) &#123; &#125;&#125;;int main() &#123; B obj_B; obj_B.f(3);// obj_B.f(); // 编译报错 f()未定义&#125; 我们可以用using声明使基类的所有f可见。继承类里的重定义会覆盖基类的定义。123456789101112131415161718#include &lt;iostream&gt;using namespace std;struct A &#123; void f() &#123; cout &lt;&lt; &quot;void A::f()&quot; &lt;&lt; endl; &#125; void f(int) &#123; cout &lt;&lt; &quot;void A::f(int)&quot; &lt;&lt; endl; &#125;&#125;;struct B : A &#123; using A::f; void f(int) &#123; cout &lt;&lt; &quot;void B::f(int)&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; B obj_B; obj_B.f(3); obj_B.f();&#125; 将会输出：12void B::f(int)void A::f() Public Overloaded Non-Virtuals Call Protected Non-Overloaded Virtuals将本需使用public重载虚函数来定义的一组函数，通过public重载非虚函数和protected不重载虚函数这种方式来定义。如：12345class Base &#123;public: virtual void f(int x); virtual void f(double x);&#125;; 可定义为：12345678class Base &#123;public: void f(int x) &#123; f_int(x); &#125; // Non-virtual void f(double x) &#123; f_dbl(x); &#125; // Non-virtualprotected: virtual void f_int(int); virtual void f_dbl(double);&#125;; 这种方式下，隐藏规则导致的风险在基类处理掉了。 参考 Name hiding - IBM Knowledge Center Overloading member functions from base and derived classes - IBM Knowledge Center Should I use protected virtuals instead of public virtuals? - isocpp]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array Left Rotation]]></title>
    <url>%2F2017%2F08%2F23%2Farray-left-rotation%2F</url>
    <content type="text"><![CDATA[A left rotation operation on an array of size n shifts each of the array’s elements 1 unit to the left. For example, if 2 left rotations are performed on array [1, 2, 3, 4, 5], then the array would become [3, 4, 5, 1, 2] .Given an array of n integers a, and a number k, perform k left rotations on the array. HackerRank Here we want solutions with O(1) additional space and O(n) time complexity. My solution Note that the element at index i is moved to (i-k) % n. Let n = 15 and k = 6, then a[0] &lt;- a[6] &lt;- a[12] &lt;- a[3] &lt;- a[9] &lt;- a[0], a[1] &lt;- a[7] &lt;- a[13] &lt;- a[4] &lt;- a[10] &lt;- a[1], a[2] &lt;- a[8] &lt;- a[14] &lt;- a[5] &lt;- a[11] &lt;- a[2]. Clearly, it forms 3 circles, and the 3 circles cover all the movement. 3 is the greatest common divisor (gcd) of 15 and 6. It should be easy to prove that, the rotation can be broken down to g (gcd of n and k) smaller circles, and within every circle are elements at index i, (i+k)%n, … We only need to rotate each circle by one step. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int gcd(int a, int b) &#123; if (b==0) return a; else return gcd(b, a%b);&#125;vector&lt;int&gt; array_left_rotation(vector&lt;int&gt; a, int n, int k) &#123; if (k==n) return a; int g = gcd (n, k); for (int j=0; j&lt; g; j++) &#123; int tmp = a[j], i = j, to_i = (i+k)%n; while (to_i !=j) &#123; a[i] = a[to_i]; i = to_i; to_i = (i+k)%n; &#125; a[i] = tmp; &#125; return a;&#125;int main()&#123; int n; int k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); for(int a_i = 0;a_i &lt; n;a_i++)&#123; cin &gt;&gt; a[a_i]; &#125; vector&lt;int&gt; output = array_left_rotation(a, n, k); for(int i = 0; i &lt; n;i++) cout &lt;&lt; output[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; There is another solution from the book, Programming Pearls. Solution 2Observation: for an array {a[0], a[1],… a[k-1], a[k], a[k+1],…a[n-1]}, after the rotation, it becomes {a[k], a[k+1]…a[n-1], a[0], a[1]… a[k-1]}. Let’s notate the a[0]~a[k-1] part as A, the latter part a[k]~ a[n-1] as B. Then what the rotation does is actually transfering AB to BA. Solution: First, reverse AB as a whole: AB -&gt; BrAr. Then, reverse Ar, Br individually: BrAr -&gt; BA 1234567891011121314151617181920212223// pay attention to the &amp; in the parametervoid swap(vector&lt;int&gt; &amp;a, int m, int l) &#123; int tmp = a[m]; a[m] = a[l]; a[l] = tmp; &#125;vector&lt;int&gt; array_left_rotation(vector&lt;int&gt; a, int n, int k) &#123; if (k==n) return a; // reverse AB as a whole for (int i=0; i &lt; n-1-i; i++) &#123; swap(a, i, n-1-i); &#125; // reverse Br for (int i=0; i&lt; n-k-1-i; i++) &#123; swap(a, i, n-k-1-i); &#125; // reverse Ar for (int i= n-k; i &lt; 2*n-k-i-1;i++) &#123; swap(a, i, 2*n-k-i-1); &#125; return a;&#125; This works, but it’s kind of tiring to get all the indices right to the swap() call.Let’s try with a reverse() helper function. And also, reverse A, B individually first, and then reverse ArBr as a whole, then we get BA. 12345678910111213141516171819void reverse(vector&lt;int&gt; &amp;a, int low, int high) &#123; while (low &lt; high) &#123; int tmp = a[low]; a[low] = a[high]; a[high] = tmp; low++; high--; &#125;&#125;vector&lt;int&gt; array_left_rotation(vector&lt;int&gt; a, int n, int k) &#123; if (k==n) return a; // reverse A reverse(a, 0, k-1); // reverse B reverse(a, k, n-1); // reverse ArBr as a whole reverse(a, 0, n-1); return a;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>rotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell tips]]></title>
    <url>%2F2017%2F05%2F11%2Fshell-tips%2F</url>
    <content type="text"><![CDATA[通配符 *shell 将通配符*替换为当前目录下的各个文件和目录，然后再传给命令。比如ls *是ls(当前目录下的所有文件 + 当前目录下所有文件夹), 其中ls(当前目录下所有文件夹) 将会列举这些文件夹下的文件(夹) 12345678➜ ls -p # append '/' at the end of a directorypkg/ tmp➜ ls *tmppkg: # list content in directory pkga.tgz.gpg read.sh 括号和大括号() 包裹的代码在子shell 里执行，{} 包含的代码在当前shell里执行12345678➜ (a=$PWD;echo $a;)/Users/lin➜ echo $a # a is not defined in current shell➜ &#123; a=$PWD;echo $a; &#125;/Users/lin➜ echo $a/Users/lin echo $((expression))运算展开12➜ echo $((1+2))3 进制 写法 含义 0开头 8进制 0x开头 16进制 [base#]n base进制，n is a number in that base 12345678➜ echo $((1))1➜ echo $((2#11))3➜ echo $((2#3))zsh: bad math expression: operator expected at `3' 单引号和双引号被双引号括起的内容常量还是常量，变量则会替换成变量内容。被单引号括起的内容不会发生替换。 12345➜ var=dablelv➜ echo &apos;$var&apos;$var➜ echo &quot;$var&quot;dablelv To be continued.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typedef详解]]></title>
    <url>%2F2017%2F05%2F11%2Ftypedef%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一行很常用的代码：1typedef int XX_Size_Check[(sizeof(XX)==64)? 1:-1]; 很容易猜到上面这行代码是要在编译时检查XX的size，但再深究点，我们就会发现它跟我们平时typedef的写法不太一致。 typedef用法小结对已有类型定义别名1typedef &lt;old type name&gt; &lt;new alias&gt;; 这是最常见的写法，主要用途有 结构体 举个例子，我们这里定义了一个结构体MyStruct，在C里面，如果要定义该类型的变量，则需要写struct关键字。(C++里在不产生歧义的情况下可以省略。） 12345struct MyStruct &#123; int data1; char data2;&#125;;struct MyStruct a; 我们可以使用typedef来简化书写： 123typedef struct MyStruct newtype;newtype a; 当然也可以直接写成这样： 1234typedef struct MyStruct &#123; int data1; char data2;&#125; newtype; 或者更简单的：1234typedef struct &#123; int data1; char data2;&#125; newtype; 指针 123typedef struct Node* NodePtr;...NodePtr startptr, endptr, curptr, prevptr, errptr, refptr; 函数指针不使用typedef，我们会这样写：12345678910int do_math(float arg1, int arg2) &#123; return arg2;&#125; int call_a_func(int (*call_this)(float, int)) &#123; int output = call_this(5.5, 7); return output;&#125; int final_result = call_a_func(&amp;do_math); 使用typedef：123456789101112typedef int (*MathFunc)(float, int); int do_math(float arg1, int arg2) &#123; return arg2;&#125; int call_a_func(MathFunc call_this) &#123; int output = call_this(5.5, 7); return output;&#125; int final_result = call_a_func(&amp;do_math); 这里typedef后面跟了一个函数指针类型 int (*MathFunc)(float, int)，通过这个语句，MathFunc成为该函数指针类型的别名。 数组1234typedef int vector[10];vector a;a[9] = 100; 和函数指针比较类似，typedef后面跟了一个数组类型（元素类型为int，数组长度为10），通过这个语句，vector成为该数组类型的别名。也可以定义多维数组。 参考：Wikipedia: typedef Jason Damon: 使用typedef语句定义数组类型]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客全记录]]></title>
    <url>%2F2017%2F04%2F18%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[why hexo曾经尝试过用github pages搭博客，用的是isnowfy提供的框架，但是有几个缺点： 发文章必须用它提供的框架，且需要将Github用户名和密码告诉它 网站样式不好看，懒癌又不会自己调整 网站自定义的维度比较小 最近看了几个用hexo搭的博客，功能基本满足我的需求，且颜值高，就果断折腾一波，我用的是Mac 。参考： EZLippi-浮生志 hexo官网 NexT主题官网 基础基础操作参考官网文档即可，5分钟搭建免费个人博客 - dimsky 这个比较简洁。 node安装慢推荐安装nvm，然后用它装node；node国内下载超级慢，得用镜像。1export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node 将这行配置加到你的shell的配置文件如.zshrc里，然后source ~/.zshrc。 另附上npm的国内镜像：12# 编辑 ~/.npmrc 加入下面内容registry = https://registry.npm.taobao.org 安装主题比如NexT12cd username.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 站点配置路径：username.github.io/_config.yml，参考：1234567title: dimsky 的 9 维空间 //你博客的名字author: dimsky //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库 主题配置路径：username.github.io/themes/next/_config.yml，参考：主题设定 - NexT 命令汇总：12345678910# nvm安装curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh# nvm使用nvm ls-remotenvm lsnvm install stablenvm install 7 # 会自动装7的最新版本# nvm usenvm use 7.9.0nvm use system 12345# hexo安装npm install hexo-cli -ghexo init username.github.iocd username.github.ionpm install 12345678# 写文章hexo new [layout] &lt;title&gt;# 启动本地服务hexo s# 安装hexo-deployer-gitnpm install hexo-deployer-git --save# 清理缓存db.json和生成文件(public)，generate，deployhexo clean &amp;&amp; hexo g &amp;&amp; hexo d 进阶主题配置 添加tags，categories，about页面 侧边栏社交链接 设置友情链接 参考：主题配置 - NexT 站内搜索Local Search - NexTHexo博客添加站内搜索 - EZLippi12# npm install hexo-generator-search --save ?npm install hexo-generator-searchdb --save 向站点配置文件添加12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能：12local_search: enable: true 注意缩进。 站点地图1npm install hexo-generator-seo-friendly-sitemap --save 向站点配置文件添加12sitemap: path: sitemap.xml 返回顶部参考：Hexo博客优化：添加返回顶部功能 - Jark，备个份。 新建文件 username.github.io/themes/next/layout/_partials/totop.ejs，在文件中加入HTML代码： 123456&lt;div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;"&gt;&lt;a title="返回顶部"&gt;&lt;img src="/imgs/scrollup.png"/&gt;&lt;/a&gt;&lt;/div&gt;&lt;!--文件引用--&gt;&lt;%- partial('totop') %&gt;&lt;script src="&lt;%- config.root %&gt;js/totop.js"&gt;&lt;/script&gt; 新建文件 username.github.io/themes/next/source/js/totop.js，在文件中添加javascript代码： 123456789101112131415161718192021222324252627(function($) &#123; // When to show the scroll link // higher number = scroll link appears further down the page var upperLimit = 1000; // Our scroll link element var scrollElem = $('#totop'); // Scroll to top speed var scrollSpeed = 500; // Show and hide the scroll to top link based on scroll position scrollElem.hide(); $(window).scroll(function () &#123; var scrollTop = $(document).scrollTop(); if ( scrollTop &gt; upperLimit ) &#123; $(scrollElem).stop().fadeTo(300, 1); // fade back in &#125;else&#123; $(scrollElem).stop().fadeTo(300, 0); // fade out &#125; &#125;); // Scroll to top animation on click $(scrollElem).click(function()&#123; $('html, body').animate(&#123;scrollTop:0&#125;, scrollSpeed); return false; &#125;);&#125;)(jQuery);// 如果对显示位置和回滚速度不满意，修改以上代码的upperLimit和scrollSpeed参数即可。 添加按钮图片。将下图复制到 username.github.io/themes/next/source/imgs 目录下，文件名为scrollup.png TODO 评论区 多说快关闭了，需要考察下用什么 博客迁移]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
