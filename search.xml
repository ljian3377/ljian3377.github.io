<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Array Left Rotation]]></title>
    <url>%2F2017%2F08%2F23%2Farray-left-rotation%2F</url>
    <content type="text"><![CDATA[A left rotation operation on an array of size n shifts each of the array’s elements 1 unit to the left. For example, if 2 left rotations are performed on array [1, 2, 3, 4, 5], then the array would become [3, 4, 5, 1, 2] .Given an array of n integers a, and a number k, perform k left rotations on the array. HackerRank Here we want solutions with O(1) additional space and O(n) time complexity. Though the OJ doesn’t require this, and the test frame it provides will ruin our effort to do it in place. My solution Note that the element at index i is moved to (i-k) % n. Let n = 15 and k = 6, then a[0] &lt;- a[6] &lt;- a[12] &lt;- a[3] &lt;- a[9] &lt;- a[0], a[1] &lt;- a[7] &lt;- a[13] &lt;- a[4] &lt;- a[10] &lt;- a[1], a[2] &lt;- a[8] &lt;- a[14] &lt;- a[5] &lt;- a[11] &lt;- a[2]. Clearly, it forms 3 circles, and the 3 circles cover all the movement. 3 is the greatest common divisor (gcd) of 15 and 6. It should be easy to prove that, the rotation can be break down to g (gcd of n and k) smaller circles, and within every circle are elements at index i, (i+k)%n, … We only need to rotate each circle by one step. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int gcd(int a, int b) &#123; if (b==0) return a; else return gcd(b, a%b);&#125;vector&lt;int&gt; array_left_rotation(vector&lt;int&gt; a, int n, int k) &#123; if (k==n) return a; int g = gcd (n, k); for (int j=0; j&lt; g; j++) &#123; int tmp = a[j], i = j, to_i = (i+k)%n; while (to_i !=j) &#123; a[i] = a[to_i]; i = to_i; to_i = (i+k)%n; &#125; a[i] = tmp; &#125; return a;&#125;int main()&#123; int n; int k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); for(int a_i = 0;a_i &lt; n;a_i++)&#123; cin &gt;&gt; a[a_i]; &#125; vector&lt;int&gt; output = array_left_rotation(a, n, k); for(int i = 0; i &lt; n;i++) cout &lt;&lt; output[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; There is another solution from the book, Programming Pearls. Solution 2Observation: for an array {a[0], a[1],… a[k-1], a[k], a[k+1],…a[n-1]}, after the rotation, it becomes {a[k], a[k+1]…a[n-1], a[0], a[1]… a[k-1]}. Let’s notate the a[0]~a[k-1] part as A, the latter part a[k]~ a[n-1] as B. Then what the rotation does is actually transfering AB to BA. Solution: First, reverse AB as a whole: AB -&gt; BrAr. Then, reverse Ar, Br individually: BrAr -&gt; BA 1234567891011121314151617181920212223// pay attention to the &amp; in the parametervoid swap(vector&lt;int&gt; &amp;a, int m, int l) &#123; int tmp = a[m]; a[m] = a[l]; a[l] = tmp; &#125;vector&lt;int&gt; array_left_rotation(vector&lt;int&gt; a, int n, int k) &#123; if (k==n) return a; // reverse AB as a whole for (int i=0; i &lt; n-1-i; i++) &#123; swap(a, i, n-1-i); &#125; // reverse Br for (int i=0; i&lt; n-k-1-i; i++) &#123; swap(a, i, n-k-1-i); &#125; // reverse Ar for (int i= n-k; i &lt; 2*n-k-i-1;i++) &#123; swap(a, i, 2*n-k-i-1); &#125; return a;&#125; This works, but it’s kind of tiring to get all the indices right to the swap() call.Let’s try with a reverse() helper function. And also, reverse A, B individually first, and then reverse ArBr as a whole, then we get BA. 12345678910111213141516171819void reverse(vector&lt;int&gt; &amp;a, int low, int high) &#123; while (low &lt; high) &#123; int tmp = a[low]; a[low] = a[high]; a[high] = tmp; low++; high--; &#125;&#125;vector&lt;int&gt; array_left_rotation(vector&lt;int&gt; a, int n, int k) &#123; if (k==n) return a; // reverse A reverse(a, 0, k-1); // reverse B reverse(a, k, n-1); // reverse ArBr as a whole reverse(a, 0, n-1); return a;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客全记录]]></title>
    <url>%2F2017%2F04%2F18%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[why hexo曾经尝试过用github pages搭博客，用的是isnowfy提供的框架，但是有几个缺点： 发文章必须用它提供的框架，且需要将Github用户名和密码告诉它 网站样式不好看，懒癌又不会自己调整 网站自定义的维度比较小 最近看了几个用hexo搭的博客，功能基本满足我的需求，且颜值高，就果断折腾一波，我用的是Mac 。参考： EZLippi-浮生志 hexo官网 NexT主题官网 基础基础操作参考官网文档即可，5分钟搭建免费个人博客 - dimsky 这个比较简洁。 node安装慢推荐安装nvm，然后用它装node；node国内下载超级慢，得用镜像。1export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node 将这行配置加到你的shell的配置文件如.zshrc里，然后source ~/.zshrc。 另附上npm的国内镜像：12# 编辑 ~/.npmrc 加入下面内容registry = https://registry.npm.taobao.org 安装主题比如NexT12cd username.github.iogit clone https://github.com/iissnan/hexo-theme-next themes/next 站点配置路径：username.github.io/_config.yml，参考：1234567title: dimsky 的 9 维空间 //你博客的名字author: dimsky //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库 主题配置路径：username.github.io/themes/next/_config.yml，参考：主题设定 - NexT 命令汇总：12345678910# nvm安装curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh# nvm使用nvm ls-remotenvm lsnvm install stablenvm install 7 # 会自动装7的最新版本# nvm usenvm use 7.9.0nvm use system 12345# hexo安装npm install hexo-cli -ghexo init username.github.iocd username.github.ionpm install 12345678# 写文章hexo new [layout] &lt;title&gt;# 启动本地服务hexo s# 安装hexo-deployer-gitnpm install hexo-deployer-git --save# 清理缓存db.json和生成文件(public)，generate，deployhexo clean &amp;&amp; hexo g &amp;&amp; hexo d 进阶主题配置 添加tags，categories，about页面 侧边栏社交链接 设置友情链接 参考：主题配置 - NexT 站内搜索Local Search - NexTHexo博客添加站内搜索 - EZLippi12# npm install hexo-generator-search --save ?npm install hexo-generator-searchdb --save 向站点配置文件添加12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能：12local_search: enable: true 注意缩进。 站点地图1npm install hexo-generator-seo-friendly-sitemap --save 向站点配置文件添加12sitemap: path: sitemap.xml 返回顶部参考：Hexo博客优化：添加返回顶部功能 - Jark，备个份。 新建文件 username.github.io/themes/next/layout/_partials/totop.ejs，在文件中加入HTML代码： 123456&lt;div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;"&gt;&lt;a title="返回顶部"&gt;&lt;img src="/imgs/scrollup.png"/&gt;&lt;/a&gt;&lt;/div&gt;&lt;!--文件引用--&gt;&lt;%- partial('totop') %&gt;&lt;script src="&lt;%- config.root %&gt;js/totop.js"&gt;&lt;/script&gt; 新建文件 username.github.io/themes/next/source/js/totop.js，在文件中添加javascript代码： 123456789101112131415161718192021222324252627(function($) &#123; // When to show the scroll link // higher number = scroll link appears further down the page var upperLimit = 1000; // Our scroll link element var scrollElem = $('#totop'); // Scroll to top speed var scrollSpeed = 500; // Show and hide the scroll to top link based on scroll position scrollElem.hide(); $(window).scroll(function () &#123; var scrollTop = $(document).scrollTop(); if ( scrollTop &gt; upperLimit ) &#123; $(scrollElem).stop().fadeTo(300, 1); // fade back in &#125;else&#123; $(scrollElem).stop().fadeTo(300, 0); // fade out &#125; &#125;); // Scroll to top animation on click $(scrollElem).click(function()&#123; $('html, body').animate(&#123;scrollTop:0&#125;, scrollSpeed); return false; &#125;);&#125;)(jQuery);// 如果对显示位置和回滚速度不满意，修改以上代码的upperLimit和scrollSpeed参数即可。 添加按钮图片。将下图复制到 username.github.io/themes/next/source/imgs 目录下，文件名为scrollup.png TODO 评论区 多说快关闭了，需要考察下用什么 博客迁移]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令注解]]></title>
    <url>%2F2017%2F04%2F11%2Flinux%E5%91%BD%E4%BB%A4%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[lsls命令的20个实用范例 – linux.cn 常用参数 参数 描述 -a –all 列出目录下的所有文件，包括以 . 开头的隐含文件 -l 除了文件名之外，还将文件的权限、链接数、所有者、文件大小等信息详细列出来 -d –directory 将目录象文件一样显示，而不是显示其下的文件 -h –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G) -t 以文件修改时间排序 -S 排序文件大小 -r （文件名字母序？）排序时反转顺序 -R recursive 递归列出子目录 -X 或–sort=extension， 扩展名排序 -p 增加 / (斜线) 标记目录 ls -d–directory 将目录象文件一样显示，而不是显示其下的文件123456$ ls pkg000000_0000.tgz.gpg 150902_1154.tgz.gpg 150907_1638.tgz.gpg sss0902.tgz.gpg 150903_1323.tgz.gpg read.sh$ ls -d pkgpkg 如果我们希望只列出目录，12345$ ls -d */pkg/ test/$ ls -d *authorized_keys BE_Introduction.odp pkg redirect start_cluster.sh test tmp 通配符 *shell 将*替换为当前目录下的各个文件和目录，然后再传给命令。比如ls *的结果，是 ls(当前目录下的所有文件 + 当前目录下所有文件夹), 即当前目录下的所有文件和当前目录下所有文件夹下的文件(夹) 1234567891011$ ls -pauthorized_keys BE_Introduction.odp pkg/ redirect start_cluster.sh test/ tmp$ ls *authorized_keys BE_Introduction.odp redirect start_cluster.sh tmppkg:000000_0000.tgz.gpg 150902_1154.tgz.gpg 150907_1638.tgz.gpg sss0902.tgz.gpg 150903_1323.tgz.gpg read.shtest: grep^：匹配正则表达式的开始行。[a,b]:匹配list中的任一个即可 grep abc[1,2] 括号和大括号() 包裹的代码在子shell 里执行，{} 包含的代码在当前shell里执行12345678$ (a=$PWD;echo $a;)/Users/lin$ echo $a$ &#123; a=$PWD;echo $a; &#125;/Users/lin$ echo $a/Users/lin echo $((expression))运算展开12$ echo $((1+2))3 进制 写法 含义 0开头 8进制 0x开头 16进制 [base#]n base进制，n is a number in that base 123456789101112131415$ 1=3$ echo $13$ echo $((1))1$ echo $((2#1))1$ echo $((2#3))zsh: bad math expression: operator expected at `3'$ echo $((2#11))3$ echo $((2#$1))zsh: bad math expression: operator expected at `3'$ echo $((8#$1))3]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typedef详解]]></title>
    <url>%2F2017%2F04%2F11%2Ftypedef%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一行很常用的代码：1typedef int XX_Size_Check[(sizeof(XX)==64)? 1:-1]; 很容易猜到上面这行代码是要在编译时检查XX的size，但再深究点，我们就会发现它跟我们平时typedef的写法不太一致。 typedef用法小结对已有类型定义别名1typedef &lt;old type name&gt; &lt;new alias&gt;; 这是最常见的写法，主要用途有 结构体 举个例子，我们这里定义了一个结构体MyStruct，在C里面，如果要定义该类型的变量，则需要写struct关键字。(C++里在不产生歧义的情况下可以省略。） 12345struct MyStruct &#123; int data1; char data2;&#125;;struct MyStruct a; 我们可以使用typedef来简化书写： 123typedef struct MyStruct newtype;newtype a; 当然也可以直接写成这样： 1234typedef struct MyStruct &#123; int data1; char data2;&#125; newtype; 或者更简单的：1234typedef struct &#123; int data1; char data2;&#125; newtype; 指针 123typedef struct Node* NodePtr;...NodePtr startptr, endptr, curptr, prevptr, errptr, refptr; 函数指针不使用typedef，我们会这样写：12345678910int do_math(float arg1, int arg2) &#123; return arg2;&#125; int call_a_func(int (*call_this)(float, int)) &#123; int output = call_this(5.5, 7); return output;&#125; int final_result = call_a_func(&amp;do_math); 使用typedef：123456789101112typedef int (*MathFunc)(float, int); int do_math(float arg1, int arg2) &#123; return arg2;&#125; int call_a_func(MathFunc call_this) &#123; int output = call_this(5.5, 7); return output;&#125; int final_result = call_a_func(&amp;do_math); 这里typedef后面跟了一个函数指针类型 int (*MathFunc)(float, int)，通过这个语句，MathFunc成为该函数指针类型的别名。 数组1234typedef int vector[10];vector a;a[9] = 100; 和函数指针比较类似，typedef后面跟了一个数组类型（元素类型为int，数组长度为10），通过这个语句，vector成为该数组类型的别名。也可以定义多维数组。 参考：Wikipedia: typedef Jason Damon: 使用typedef语句定义数组类型]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>typedef</tag>
      </tags>
  </entry>
</search>
